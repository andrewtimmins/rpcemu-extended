// c.Module
//
//  This program is free software; you can redistribute it and/or modify it
//  under the terms of version 2 of the GNU General Public License as
//  published by the Free Software Foundation;
//
//  This program is distributed in the hope that it will be useful, but WITHOUT
//  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
//  more details.
//
//  You should have received a copy of the GNU General Public License along with
//  this program; if not, write to the Free Software Foundation, Inc., 59
//  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
//  The full GNU General Public License is included in this distribution in the
//  file called LICENSE.

//  The code in this file is (C) 2003 J Ballance as far as
//  the above GPL permits
//
//  Modifications for RPCEmu (C) 2007 Alex Waugh

#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include "ModHdr.h"
#include "dcistructs.h"
#include "Defines.h"
#include "errors.h"
#include "Structs.h"

/// Directly include a binary version of the AutoSense file (as a C array)
#include "AutoSense.c"

#define  UNUSED(x)              (x = x)

#define INQUIRE_FLAGS	(INQ_MULTICAST | INQ_PROMISCUOUS | INQ_RXERRORS | \
			 INQ_HWADDRVALID | INQ_SOFTHWADDR | INQ_HASSTATS)

_kernel_oserror *networktxswi(struct mbuf *mbufs, int dest, int src, int frametype);
_kernel_oserror *networkrxswi(struct mbuf *mbuf, RxHdr *hdr, int *valid);
void network_swi_irq(volatile int *irqstatus);
void network_swi_hwaddr(uint8_t *hwaddr);
void callrx(Dib *dibaddr, struct mbuf *mbuf_chain, int handler, void *pwp);

// versionof DCI supported
#define DCIVersion 403

static workspace work;

static const struct stats supported = {
	// General information
	UCHAR_MAX,	// st_interface_type
	UCHAR_MAX,	// st_link_status
	UCHAR_MAX,	// st_link_polarity
	0,		// st_blank1
	0,		// st_link_failures
	0,		// st_network_collisions

	// Transmit statistics
	0,		// st_collisions
	0,		// st_excess_collisions
	0,		// st_heartbeat_failures
	0,		// st_not_listening
	ULONG_MAX,	// st_tx_frames
	0,		// st_tx_bytes
	ULONG_MAX,	// st_tx_general_errors
	{ 0, 0, 0, 0, 0, 0, 0, 0, },	// st_last_dest_addr

	// Receive statistics
	0,		// st_crc_failures
	0,		// st_frame_alignment_errors
	0,		// st_dropped_frames
	0,		// st_runt_frames
	0,		// st_overlong_frames
	0,		// st_jabbers
	0,		// st_late_events
	ULONG_MAX,	// st_unwanted_frames
	ULONG_MAX,	// st_rx_frames
	0,		// st_rx_bytes
	ULONG_MAX,	// st_rx_general_errors
	{ 0, 0, 0, 0, 0, 0, 0, 0 },	// st_last_src_addr
};

// mbufs waiting to be used, to save frequent allocation and deallocation
static struct mbuf *rxhdr_mbuf = NULL;
static struct mbuf *data_mbuf = NULL;

#define MBUF_MANAGER_VERSION 100


/// List of locations to try to install the AutoSense file
static const char *autosense_locations[] = {
	"<Boot$Dir>.Resources.Configure.!InetSetup.AutoSense.EtherRPCEm",
	"<Boot$Dir>.RO420Hook.Res.Configure.!NetSetup.!IFSetup.AutoSense.EtherRPCEm",
	"<Boot$Dir>.RO430Hook.Res.Configure.!NetSetup.!IFSetup.AutoSense.EtherRPCEm",
	"<Boot$Dir>.RO440Hook.Res.Configure.!NetSetup.!IFSetup.AutoSense.EtherRPCEm",
	NULL
};

/**
 * Try to install the AutoSense file into the required location in the Boot
 * sequence.
 */
static void
autosense_install(void)
{
	_kernel_swi_regs r;
	size_t i;

	// Determine if Boot$Dir is set
	r.r[0] = (int) "Boot$Dir";
	r.r[1] = 0;
	r.r[2] = -1;
	r.r[3] = 0;
	_kernel_swi(OS_ReadVarVal, &r, &r);
	if (r.r[2] >= 0) {
		// Boot$Dir is not set
		return;
	}

	for (i = 0; autosense_locations[i] != NULL; i++) {
		const char *location = autosense_locations[i];
		_kernel_oserror *err;

		// Read information about current autosense file (if it exists)
		r.r[0] = 17;
		r.r[1] = (int) location;
		err = _kernel_swi(OS_File, &r, &r);
		if (err != NULL || r.r[0] != 0) {
			// Already exists (or an error occurred)
			continue;
		}

		// Copy autosense data to location
		r.r[0] = 10;
		r.r[1] = (int) location;
		r.r[2] = 0xffb;
		r.r[4] = (int) autosense_file;
		r.r[5] = (int) (autosense_file + sizeof(autosense_file));
		_kernel_swi(OS_File, &r, &r);
	}
}

/**
 * Issue service call during initialisation and finalisation to notify
 * protocol modules of new driver.
 *
 * @param startstop 0 for starting, 1 for stopping
 */
static void
SendServiceDCIDriverStatus(int startstop)
{
	_kernel_swi_regs r;

	r.r[0] = (int) &work.base_dib;
	r.r[1] = Service_DCIDriverStatus;
	r.r[2] = startstop;
	r.r[3] = DCIVersion;
	_kernel_swi(OS_ServiceCall, &r, &r);
}

/**
 * called in callback time for a variety of reasons
 */
_kernel_oserror *
initialise_callback_handler(_kernel_swi_regs *r, void *pw)
{
	UNUSED(r);
	UNUSED(pw);

	SendServiceDCIDriverStatus(DCIDRIVER_STARTING);

	return NULL;
}

/**
 * Open Mbuf memory manager session
 */
static _kernel_oserror *
open_mbuf_manager_session(dci4_mbctl *mbctl)
{
	_kernel_swi_regs r;

	memset(mbctl, 0, sizeof(struct mbctl));
	mbctl->mbcsize = sizeof(struct mbctl);
	mbctl->mbcvers = MBUF_MANAGER_VERSION;
	mbctl->flags = 0;
	mbctl->advminubs = 0;
	mbctl->advmaxubs = 0;
	mbctl->mincontig = 0;
	mbctl->spare1 = 0;

	r.r[0] = (int) mbctl;
	return _kernel_swi(Mbuf_OpenSession, &r, &r);
}

/**
 * Close Mbuf memory manager session
 */
static _kernel_oserror *
close_mbuf_manager_session(dci4_mbctl *mbctl)
{
	_kernel_swi_regs r;

	r.r[0] = (int) mbctl;
	return _kernel_swi(Mbuf_CloseSession, &r, &r);
}

/**
 * Report frame release, unlink it, and free memory
 *
 * @param cb Pointer to ClaimBuf to release
 */
static void
bounceclaim(ClaimBuf *cb)
{
	_kernel_swi_regs r;

	// Report it's now no longer claimed
	r.r[0] = (int) &work.base_dib;
	r.r[1] = Service_DCIFrameTypeFree;
	r.r[2] = cb->frame_type | (cb->frame_level << 16);;
	r.r[3] = cb->address_level;
	r.r[4] = cb->error_level;
	_kernel_swi(OS_ServiceCall, &r, &r);

	// Unlink from list
	if (cb->prev != NULL) {
		cb->prev->next = cb->next;
	} else {
		work.claims = cb->next;
	}
	if (cb->next != NULL) {
		cb->next->prev = cb->prev;
	}

	free(cb);
}

/**
 */
static void
InitChip(void *pw)
{
	_kernel_swi_regs r;

	work.base_dib.dib_swibase = EtherRPCEm_00;
	work.base_dib.dib_name = "rpcem";
	work.base_dib.dib_unit = 0;
	work.base_dib.dib_address = work.dev_addr;
	work.base_dib.dib_module = "EtherRPCEm";
	work.base_dib.dib_location = "Emulated";
	work.base_dib.dib_slot.sl_slotid = 0;
	work.base_dib.dib_slot.sl_minor = 0;
	work.base_dib.dib_slot.sl_pcmciaslot = 0;
	work.base_dib.dib_slot.sl_mbz = 0;
	work.base_dib.dib_inquire = INQUIRE_FLAGS;
	work.claims = NULL; // flag no claimbufs

	r.r[0] = (int) "Inet$EtherType";
	r.r[1] = (int) work.base_dib.dib_name;
	r.r[2] = (int) strlen((char *) r.r[1]);
	r.r[3] = 0;
	r.r[4] = 4;
	_kernel_swi(OS_SetVarVal, &r, &r);

	r.r[0] = (int) initialise_callback; // where to call
	r.r[1] = (int) pw;
	_kernel_swi(OS_AddCallBack, &r, &r);
}

/**
 * Module initialisation code
 */
_kernel_oserror *
initialise(const char *cmd_tail, int podule_base, void *pw)
{
	_kernel_oserror *err;
	int ribuff[2];
	uint8_t *PodMaskAddr;
	uint8_t PodMask;

	UNUSED(cmd_tail);

	memset(&work, 0, sizeof(work));

	network_swi_hwaddr(work.dev_addr);

	work.pwp = pw;

	// claim mbuf manager link
	if ((work.mbctl = calloc(1, sizeof(dci4_mbctl))) == NULL) {
		return &ERR_ENOBUFS;
	}

	if ((err = open_mbuf_manager_session(work.mbctl)) != NULL) {
		return err;
	}

	InitChip(pw);

	err = _swix(OS_ClaimDeviceVector, _INR(0,4), 13, device_irq, pw, podule_base, 1);
	if (err) {
		return err;
	}

	// Enable Podule IRQs
	err = _swix(Podule_ReadInfo, _INR(0,3), (1 << 16) | (1 << 15), ribuff, sizeof(ribuff), podule_base);
	if (err) {
		return err;
	}

	PodMaskAddr = (uint8_t *) ribuff[0]; // Pointer to location to enable Podule IRQs
	PodMask = (uint8_t) ribuff[1]; // Bit mask to enable Podule IRQs

	_kernel_irqs_off();
	*PodMaskAddr |= PodMask; // Enable podule IRQs
	_kernel_irqs_on();

	// The value passed here no longer matters, provided it's non-zero
	network_swi_irq((int *) 1);

	return NULL;
}

/**
 * Module finalisation code
 */
_kernel_oserror *
finalise(int fatal, int podule, void *pw)
{
	ClaimBuf *c, *next;

	// ints off to ensure it stays quiet..
	_kernel_irqs_off();

	network_swi_irq(0);
	_swix(OS_ReleaseDeviceVector, _INR(0,4), 13, device_irq, pw, podule, 1);

	SendServiceDCIDriverStatus(DCIDRIVER_DYING); // flag we're stopping

	// Free memory of Claims
	for (c = work.claims; c != NULL; c = next) {
		next = c->next;
		free(c);
	}

	// End Mbuf Manager session
	if (work.mbctl != NULL) {
		if (rxhdr_mbuf != NULL) {
			work.mbctl->freem(work.mbctl, rxhdr_mbuf);
		}
		if (data_mbuf != NULL) {
			work.mbctl->freem(work.mbctl, data_mbuf);
		}

		close_mbuf_manager_session(work.mbctl);
		free(work.mbctl);
	}

	return NULL;
}

/**
 * Look for whether a Protocol Module has claimed this particular frame type
 *
 * @param frame_type Frame type of received frame (or length if IEEE)
 * @return Pointer to Claim information, or NULL if not claimed by a Protocol Module
 */
static inline const ClaimBuf *
find_protocol(int frame_type)
{
	const ClaimBuf *c;

	if (frame_type <= 1500) {
		// Interpret as IEEE length field - is IEEE claimed?
		for (c = work.claims; c != NULL; c = c->next) {
			if (c->frame_level == FRMLVL_IEEE) {
				return c;
			}
		}

	} else {
		// Any Protocol Module wants this frame type, or claimed all frame types?
		for (c = work.claims; c != NULL; c = c->next) {
			if ((c->frame_type == frame_type) || (c->frame_level == FRMLVL_E2MONITOR)) {
				return c;
			}
		}

		// If no-one wants this frame type, any Protocol Module want unclaimed types?
		for (c = work.claims; c != NULL; c = c->next) {
			if (c->frame_level == FRMLVL_E2SINK) {
				return c;
			}
		}
	}

	return NULL;
}

/**
 */
_kernel_oserror *
device_irq_handler(_kernel_swi_regs *r, void *pw)
{
	static volatile int sema = 0;
	_kernel_swi_regs rg;

	// Clear interrupt
	rg.r[0] = 3;
	rg.r[2] = 0;
	_kernel_swi(0x56ac4, &rg, &rg);

	if (sema) {
		return NULL;
	}
	sema = 1;

	for (;;) {
		RxHdr *rxhdr;
		int valid;
		const ClaimBuf *c;

		if (rxhdr_mbuf == NULL) {
			rxhdr_mbuf = work.mbctl->alloc_s(work.mbctl, sizeof(RxHdr), NULL);
		}
		if (data_mbuf == NULL) {
			data_mbuf = work.mbctl->alloc_s(work.mbctl, 1500, NULL);
		}

		if (rxhdr_mbuf == NULL || data_mbuf == NULL) {
			// mbuf exhaustion
			sema = 0;
			return NULL;
		}

		rxhdr = (RxHdr *) (((char *) rxhdr_mbuf) + rxhdr_mbuf->m_off);
		rxhdr_mbuf->m_len = sizeof(RxHdr);
		if (networkrxswi(data_mbuf, rxhdr, &valid) || !valid) {
			// No data
			sema = 0;
			return NULL;
		}

		// Increment receive frames
		work.st_rx_frames++;

		// Does any Protocol Module want this frame type?
		if ((c = find_protocol(rxhdr->rx_frame_type)) == NULL) {
			// No Protocol Module wants this frame
			work.st_unwanted_frames++;
			continue;
		}

		rxhdr_mbuf->m_next = data_mbuf; // link them together
		rxhdr_mbuf->m_list = 0; // this is needed
		//data_mbuf->m_next = NULL;      // link them together
		data_mbuf->m_list = 0; // this is needed
		// at this point we dont need to check for safe mbuf
		// as we've used the alloc routine that only allocs
		// mbufs that actually are safe

		// now build the rxhdr structure
		rxhdr_mbuf->m_type = MT_HEADER;

		// Call the Protocol Module
		_kernel_irqs_on();
		callrx(&work.base_dib, rxhdr_mbuf, c->handler, c->pwp);
		_kernel_irqs_off();

		// The Protocol Module is now responsible for freeing the mbufs
		rxhdr_mbuf = NULL;
		data_mbuf = NULL;
	}
}

/**
 * Module service call handler
 */
void
service_call(int service_number, _kernel_swi_regs *r, void *pw)
{
	_kernel_swi_regs rg;
	_kernel_oserror *erp;

	switch (service_number) {
	case Service_StartWimp:
		autosense_install();
		break;

	case Service_EnumerateNetworkDrivers: // on entry, r0-> chain of dibs
		rg.r[0] = RMAClaim;
		rg.r[3] = sizeof(ChDib);
		if ((erp = _kernel_swi(OS_Module, &rg, &rg)) == NULL) {
			// got extra memory to add chaindib
			((ChDib *) rg.r[2])->chd_dib = &work.base_dib;
			((ChDib *) rg.r[2])->chd_next = (ChDib *) r->r[0];
			r->r[0] = rg.r[2]; // link our chaindib into the chain
		}
		break;

	case Service_DCIProtocolStatus:
		break;

	case Service_MbufManagerStatus:
		switch (r->r[0]) {
		case 0: // Manager started ... better try to restart our stuff
			if (work.mbctl == NULL) {
				if ((erp = open_mbuf_manager_session(work.mbctl)) == NULL) {
					InitChip(work.pwp);
				}
			}
			break;
		case 1: // Manager stopping .. cannot if sessions are active
			if (work.mbctl != NULL) {
				// claim .. we're active
				r->r[1] = 0;
			}
			break;
		default: // Manager scavenge
			break;
		}
		break;
	}
}

/**
 * Module SWI handler
 */
_kernel_oserror *
swi_handler(int swi_offset, _kernel_swi_regs *r, void *private_word)
{
	ClaimBuf *c, *nc;
	_kernel_oserror *err;

	UNUSED(private_word);

	switch (swi_offset) {
	// return version num of DCI spec implelmented
	// on entry:	r0 = flags (all zero)
	// on exit:	r1 = version (4.03 at present)
	case DCI4Version:
		if (r->r[0] != 0) {
			return &ERR_EINVAL;
		}
		r->r[1] = DCIVersion;
		break;

	// return bitmap of supported features
	// on entry:	r0 = flags (all zero)
	//		r1 = unit number
	// on exit:	r2 = info word
	case DCI4Inquire:
		if (r->r[0] != 0) {
			return &ERR_EINVAL;
		}
		r->r[2] = INQUIRE_FLAGS;
		break;

	// return physical MTU size of supported network
	// on entry:	r0 = flags (all zero)
	//		r1 = unit number
	// on exit:	r2 = MTU size
	case DCI4GetNetworkMTU:
		if (r->r[0] != 0) {
			return &ERR_EINVAL;
		}
		r->r[2] = EY_MTU;
		break;

	// set physical MTU size of supported network
	// on entry:	r0 = flags (all zero)
	//		r1 = unit number
	//		r2 = new MTU
	// if size change not supported, return illegal op error
	// on exit, illegal op error!
	case DCI4SetNetworkMTU:
		if (r->r[0] != 0) {
			return &ERR_EINVAL;
		}
		return &ERR_ENOTTY;

	// transmit data
	// on entry:	r0 = flags (see below)
	//		r1 = unit number
	//		r2 = frame type
	//		r3 -> mbuf chain of data to tx
	//		r4 -> dest h/w address (byte aligned)
	//		r5 -> srce h/w address (byte aligned)(if needed)
	// on exit:	all regs preserved
	//
	// Flags:	bit 0:	0 = use own H/W address
	//			1 = use r5 as srce H/W addr
	//		bit 1:	0 = driver to assume ownership of mbuf chain
	//			1 = driver does not own mbuf chain
	case DCI4Transmit: {
		struct mbuf *mbufchain = (struct mbuf *) r->r[3];

		err = NULL;

		while (mbufchain != NULL) {
			struct mbuf *next = mbufchain->m_list;

			if (err == NULL) {
				err = networktxswi(mbufchain, r->r[4], (r->r[0] & 1) ? r->r[5] : 0, r->r[2]);
				// Increment transmit frames
				work.st_tx_frames++;
			}

			if ((r->r[0] & 2) == 0) {
				work.mbctl->freem(work.mbctl, mbufchain);
			}
			mbufchain = next;
		}
		return err; // Return error if any
	}

	// on entry:	r0 = flags (see below)
	//		r1 = unit number
	//		r2 = frame type/class
	//			bottom 16 bits: frame type (if 'frame level' is specific)
	//			top 16 bits: 'frame level':
	//				1.. specific        2.. sink
	//				3.. monitor         4.. ieee
	//		r3 = address level (for write)
	//		r4 = error level (for write)
	//		r5 = handlers private word pointer
	//		r6 = address of routine to receive this frame
	//
	// on exit:	all regs preserved
	//
	// Flags:	bit 0:	0 = claim frame type
	//			1 = release frame type
	//		bit 1:  0 = drivers can pass unsafe mbuf chains back
	//			1 = ensure_safe required before mbufs passed back
	case DCI4Filter:
		if (r->r[1] != 0) {
			// only unit 0 supported at present
			return &ERR_ENXIO;
		}
		if ((r->r[0] & 1) != 0) {
			// release frame
			for (c = work.claims; c != NULL; c = c->next) {
				if ((c->unit == r->r[1]) &&
				    (c->frame_type == GET_FRAMETYPE(r->r[2])) &&
				    (c->frame_level == GET_FRAMELEVEL(r->r[2])) &&
				    (c->address_level == r->r[3]) &&
				    (c->error_level == r->r[4]) &&
				    (c->pwp == (void *) r->r[5]) &&
				    (c->handler == r->r[6]))
				{
					// we've found the claim, unlink it
					bounceclaim(c);
					break;
				}
			}
		} else {
			// claim frame type
			const int frame_type = GET_FRAMETYPE(r->r[2]);
			const int frame_level = GET_FRAMELEVEL(r->r[2]);

			// frame_type must be zero if frame_level is not Specific
			if (frame_level != FRMLVL_E2SPECIFIC && frame_type != 0) {
				return &ERR_EINVAL;
			}

			switch (frame_level) {
			case FRMLVL_E2SPECIFIC:
				// Make sure this Frame Type hasn't been claimed already
				for (c = work.claims; c != NULL; c = c->next) {
					if (c->frame_type == frame_type) {
						return &ERR_AlreadyClaimed;
					}
				}
				break;
			case FRMLVL_E2SINK:
				// Make sure Sink hasn't been claimed already
				for (c = work.claims; c != NULL; c = c->next) {
					if (c->frame_level == FRMLVL_E2SINK) {
						return &ERR_AlreadyClaimed;
					}
				}
				break;
			case FRMLVL_E2MONITOR:
				// Make sure there are no Ethernet 2.0 claims already
				for (c = work.claims; c != NULL; c = c->next) {
					if (c->frame_level != FRMLVL_IEEE) {
						return &ERR_AlreadyClaimed;
					}
				}
				break;
			case FRMLVL_IEEE:
				// Make sure there is no IEEE claim already
				for (c = work.claims; c != NULL; c = c->next) {
					if (c->frame_level == FRMLVL_IEEE) {
						return &ERR_AlreadyClaimed;
					}
				}
				break;
			default:
				return &ERR_EINVAL;
			}

			// Allocate and initialise new Claim
			if ((nc = calloc(1, sizeof(ClaimBuf))) == NULL) {
				return &ERR_ENOBUFS;
			}
			nc->flags = r->r[0] & 1;
			nc->unit = r->r[1];
			nc->frame_type = frame_type;
			nc->frame_level = frame_level;
			nc->address_level = r->r[3];
			nc->error_level = r->r[4];
			nc->pwp = (void *) r->r[5];
			nc->handler = r->r[6];

			// Link into list
			nc->next = work.claims;
			nc->prev = NULL;
			if (work.claims != NULL) {
				work.claims->prev = nc;
			}
			work.claims = nc;
		}
		// now check all claims and set multicast or promiscuous as needed
		work.flags = 0;
		for (c = work.claims; c != NULL; c = c->next) {
			if (c->address_level == ADDRLVL_MULTICAST) {
				work.flags |= IFF_ALLMULTI;
			}
			if (c->address_level == ADDRLVL_PROMISCUOUS) {
				work.flags |= IFF_PROMISC;
			}
		}
		break;

	// return unit statistics
	// on entry:	r0 = flags (see below)
	//		r1 = unit number
	//		r2 -> buffer for results
	// on exit:	all regs preserved
	//
	// Flags:	bit 0:	0 = indicate which stats are gathered
	//			1 = return actual stats
	case DCI4Stats:
		if ((r->r[0] & 1) != 0) {
			// return actual stats
			struct stats *stats = (struct stats *) r->r[2];

			// Set all statistics to zero (including implemented error counters)
			memset(stats, 0, sizeof(struct stats));

			stats->st_interface_type = ST_TYPE_10BASET;
			stats->st_link_status = ST_STATUS_OK |
			                        ST_STATUS_ACTIVE |
			                        ST_STATUS_PROMISCUOUS |
			                        ST_STATUS_FULL_DUPLEX;
			stats->st_link_polarity = ST_LINK_POLARITY_CORRECT;
			stats->st_tx_frames = work.st_tx_frames;
			stats->st_unwanted_frames = work.st_unwanted_frames;
			stats->st_rx_frames = work.st_rx_frames;
		} else {
			// indicate what's supported
			memcpy((void *) r->r[2], &supported.st_interface_type, sizeof(struct stats));
		}
		break;

	// on entry:	r0 = flags (see below)
	//		r1 = unit number
	//		r2 = frame type
	//		r3 ->(byte aligned) multicast hardware (MAC) address
	//		r4 ->(word aligned) multicast IP address
	//		r5 = priv word ptr
	//		r6 = address of handler routine to receive frames
	// on exit:	all regs preserved
	//
	// Flags:	bit 0:	0 = request an mc addr
	//			1 = release an mc addr
	//		bit 1:	0 = request/release specific mc addr (in r3 & r4)
	//			1 = request/release all mc addrs
	case DCI4MulticastRequest:
		if (r->r[0] && ~3) {
			printf("\n EYmulticast not fully implemented yet\n");
		}
		break;

	default:
		return error_BAD_SWI;
	}

	return NULL;
}

/**
 * Module command handler
 *
 * @param arg_string command tail
 * @param argc       number of parameters
 * @param cmd_no     command number (value generated by CMHG)
 * @param pw         private word pointer
 * @return error pointer or NULL
 */
_kernel_oserror *
command_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{
	const ClaimBuf *c;

	switch (cmd_no) {
	case CMD_ERPCEmInfo:
		printf("Interface address   : %02x:%02x:%02x:%02x:%02x:%02x\n",
		    work.dev_addr[0], work.dev_addr[1], work.dev_addr[2],
		    work.dev_addr[3], work.dev_addr[4], work.dev_addr[5]);

		printf("Packets sent        : %lu\n", work.st_tx_frames);
		printf("Packets received    : %lu\n", work.st_rx_frames);

		printf("Undelivered packets : %lu\n", work.st_unwanted_frames);

		printf("Filter clients:\n");
		for (c = work.claims; c != NULL; c = c->next) {
			printf("    frame_type = %04x, frame_level = %d, address_level = %d, error_level = %d\n",
			    c->frame_type, c->frame_level, c->address_level, c->error_level);
		}
		break;
	}

	return NULL;
}
